<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prüfungs-Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css">
    <style>
        /* === Design Tokens === */
        :root {
          /* Colors - Primary (seaborn green) */
          --color-primary-500: #2ca02c;
          --color-primary-600: #238c23;
          --color-primary-700: #1a6b1a;
          --color-primary-50: #f0f9f0;
          --color-primary-100: #d4f1d4;
          
          /* Colors - Semantic (seaborn palette) */
          --color-success: #2ca02c;
          --color-error: #d62728;
          --color-warning: #ff7f0e;
          --color-info: #1f77b4;
          
          /* Colors - Neutral */
          --color-surface: #ffffff;
          --color-bg: #f6f7f8;
          --color-text: #1f2d33;
          --color-text-muted: #8e98a1;
          --color-border: #e3e7ea;
          --color-hover: #f0f2f3;
          
          /* Dashboard specific colors (darker for readability on background) */
          --color-dashboard-text: #2c3e50;
          --color-dashboard-text-muted: #34495e;
          
          /* Spacing Scale */
          --space-1: 4px;
          --space-2: 8px;
          --space-3: 12px;
          --space-4: 16px;
          --space-5: 20px;
          --space-6: 24px;
          --space-8: 32px;
          
          /* Typography */
          --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
          --font-size-sm: 14px;
          --font-size-base: 15px;
          --font-size-lg: 18px;
          --font-size-xl: 20px;
          --font-weight-normal: 400;
          --font-weight-medium: 500;
          --font-weight-semibold: 600;
          --line-height-tight: 1.3;
          --line-height-normal: 1.5;
          --line-height-relaxed: 1.6;
          
          /* Border Radius */
          --radius-sm: 4px;
          --radius: 6px;
          --radius-lg: 8px;
          
          /* Shadows */
          --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
          --shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
          --shadow-md: 0 2px 6px rgba(0, 0, 0, 0.15);
          --shadow-lg: 0 4px 12px rgba(0, 0, 0, 0.2);
          
          /* Transitions */
          --transition-fast: 150ms ease;
          --transition-base: 200ms ease;
          --transition-slow: 300ms ease;
        }

        /* General Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Focus styles for accessibility */
        *:focus-visible {
          outline: 2px solid var(--color-primary-500);
          outline-offset: 2px;
        }

        /* Body and Background Styling */
        body {
            font-family: var(--font-family);
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            height: 100vh;
            /* Prevent body from scrolling */
            overflow: hidden;
            position: relative;
            font-size: var(--font-size-base);
            font-weight: var(--font-weight-normal);
            line-height: var(--line-height-normal);
            color: var(--color-dashboard-text);
        }

        /* Overlay for background effect */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 1;
        }

        /* Main Container for Dashboard Layout */
        .container {
            position: relative;
            z-index: 2;
            padding: var(--space-5);
            display: flex;
            /* Use flexbox for a column layout */
            flex-direction: column;
            /* Occupy full viewport height */
            height: 100vh;
            gap: var(--space-3);
            /* Spacing between sections */
            max-width: 90%;
            width: 100%;
            /* Center the container */
            margin: 0 auto;
            border-radius: var(--radius-lg);
            overflow: hidden;
        }

        /* Shared Card Styling */
        .date-info,
        .timer-section,
        .additional-info {
            background: rgba(255, 255, 255, 0.95);
            /* Slightly transparent white background */
            border-radius: var(--radius-lg);
            /* Rounded corners for individual cards */
            padding: var(--space-4) var(--space-6);
            /* Padding inside cards */
            box-shadow: var(--shadow-lg);
            /* Soft shadow */
            backdrop-filter: blur(10px);
            /* Frosted glass effect */
            border: 1px solid rgba(255, 255, 255, 0.2);
            /* Subtle border */
            transition: all var(--transition-base);
        }
        
        .date-info:hover,
        .timer-section:hover,
        .additional-info:hover {
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        /* Date and Time Info Section (ROW 1 - FIXED HEIGHT) */
        .date-info {
            /* This row will not grow or shrink; its height is based on its content. */
            flex: 0 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            /* Allow wrapping on smaller screens */
            gap: var(--space-3);
            /* Spacing between date and time elements */
        }

        .date-display {
            font-size: 36px;
            font-weight: var(--font-weight-semibold);
            color: var(--color-dashboard-text);
            line-height: var(--line-height-tight);
        }

        .time-info {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .time-label {
            font-size: 30px;
            /* Adjusted for better readability */
            color: var(--color-text-muted);
            font-weight: var(--font-weight-medium);
        }

        .time-value {
            font-size: 36px;
            font-weight: var(--font-weight-semibold);
            color: var(--color-dashboard-text);
            line-height: var(--line-height-tight);
        }

        .time-input {
            font-size: 30px;
            /* Match label font size */
            padding: var(--space-2) var(--space-3);
            border: 2px solid var(--color-border);
            border-radius: var(--radius);
            width: 120px;
            /* Fixed width for time input */
            text-align: center;
            font-family: var(--font-family);
            transition: border-color var(--transition-fast);
            background: var(--color-surface);
        }
        
        .time-input:hover {
            border-color: var(--color-text-muted);
        }
        
        .time-input:focus {
            border-color: var(--color-primary-500);
            outline: none;
            box-shadow: 0 0 0 3px var(--color-primary-50);
        }

        /* Timer Section (ROW 2 - FIXED HEIGHT) */
        .timer-section {
            /* This row will also not grow or shrink. */
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-4) var(--space-6);
        }

        .timer-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-8);
            flex-wrap: wrap;
        }

        .timer-label {
            font-size: 36px;
            color: var(--color-dashboard-text-muted);
            font-weight: var(--font-weight-semibold);
            line-height: var(--line-height-tight);
        }

        .timer-display {
            font-size: 120px;
            font-weight: var(--font-weight-semibold);
            color: var(--color-dashboard-text);
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            /* Monospaced font for timer */
            line-height: 1;
            border: 2px solid transparent;
            /* Transparent border for editing */
            border-radius: var(--radius);
            transition: border-color var(--transition-fast);
            cursor: pointer;
            line-height: var(--line-height-tight);
        }

        .timer-display:focus {
            border-color: var(--color-primary-500);
            outline: none;
            background: rgba(255, 255, 255, 0.8);
        }

        /* Progress Bar */
        .progress-bar-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-1);
        }

        .progress-label {
            font-size: 30px;
            font-weight: var(--font-weight-medium);
            color: var(--color-dashboard-text-muted);
        }

        .progress-total {
            cursor: pointer;
            border-bottom: 1px dashed var(--color-text-muted);
            min-width: 1.5em;
            display: inline-block;
            text-align: center;
        }

        .progress-total:focus {
            outline: none;
            border-bottom-color: var(--color-primary-500);
            border-bottom-style: solid;
        }

        .progress-bar {
            display: flex;
            gap: 3px;
            width: 100%;
            justify-content: center;
        }

        .progress-tile {
            height: 20px;
            min-width: 12px;
            flex: 1 1 auto;
            max-width: 60px;
            border-radius: var(--radius-sm);
            background: var(--color-border);
            transition: background var(--transition-fast);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .progress-tile.completed {
            background: var(--color-success);
            border-color: var(--color-primary-600);
        }

        .progress-tile.current {
            background: var(--color-warning);
            border-color: #e6720e;
            animation: tilePulse 1.5s ease-in-out infinite;
        }

        @keyframes tilePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Timer Controls (Buttons inside Timer Section) */
        .timer-controls {
            display: flex;
            gap: var(--space-3);
            /* Spacing between buttons */
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            /* Allow buttons to wrap */
        }

        /* === Buttons === */
        .btn,
        .btn-small {
            padding: var(--space-3) var(--space-6);
            border: none;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-medium);
            font-family: var(--font-family);
            transition: all var(--transition-fast);
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            line-height: var(--line-height-normal);
        }
        
        .btn:hover,
        .btn-small:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .btn:active,
        .btn-small:active {
            transform: translateY(0);
        }

        /* Button Icon Styling */
        .btn span,
        .btn-small span {
            font-size: 1.5em;
            /* Make symbol a bit larger than button text */
            line-height: 1;
            /* Ensure vertical centering */
            color: inherit;
            /* Inherit color from parent button */
        }

        .btn-primary {
            background: var(--color-primary-500);
            color: white;
        }

        .btn-primary:hover {
            background: var(--color-primary-600);
        }

        .btn-primary:active {
            background: var(--color-primary-700);
        }

        .btn-success {
            background: var(--color-success);
            color: white;
        }

        .btn-success:hover {
            background: var(--color-primary-600);
        }

        .btn-warning {
            background: var(--color-warning);
            color: white;
        }

        .btn-warning:hover {
            background: #e6720e;
        }

        /* Small Buttons (for file controls) */
        .btn-small {
            font-size: var(--font-size-base);
            padding: var(--space-2) var(--space-4);
            border-radius: var(--radius);
            box-shadow: var(--shadow-sm);
            background: var(--color-surface);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }
        
        .btn-small:hover {
            background: var(--color-hover);
            border-color: var(--color-text-muted);
        }

        /* Additional Information Section (ROW 3 - FILLS REMAINING SPACE) */
        .additional-info {
            /* This row will grow to fill all available vertical space. */
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            /* Hide this container's overflow; the inner .info-display will scroll. */
            overflow: hidden;
        }

        .info-display {
            /* Takes remaining space inside its parent */
            flex: 1;
            /* Takes remaining space */
            margin-bottom: var(--space-5);
            /* Enable scrolling for overflowing content */
            overflow-y: auto;
            /* Enable scrolling for overflowing content */
            padding-right: var(--space-3);
            /* Padding for scrollbar */
            /* height will be set by JS */
        }

        .info-item {
            margin-bottom: 0.1em;
            padding: var(--space-3);
            background: var(--color-surface);
            border-radius: var(--radius);
            border: 1px solid var(--color-border);
            box-shadow: var(--shadow-sm);
            display: flex;
            /* Use flexbox for "Aufgabe X)" and text */
            align-items: baseline;
            /* Align items to their baselines */
            gap: var(--space-3);
            /* Space between label and text */
            transition: all var(--transition-fast);
        }
        
        .info-item:hover {
            box-shadow: var(--shadow);
            border-color: var(--color-primary-500);
        }

        .info-item .delete-btn {
            opacity: 0;
            transition: opacity var(--transition-base);
            background: none;
            border: none;
            color: var(--color-error);
            cursor: pointer;
            font-size: 16px;
            padding: var(--space-1);
            flex-shrink: 0;
            align-self: center;
        }

        .info-item:hover .delete-btn {
            opacity: 0.5;
        }

        .info-item .delete-btn:hover {
            opacity: 1;
        }

        .info-question {
            font-weight: var(--font-weight-semibold);
            color: var(--color-dashboard-text);
            flex-shrink: 0;
            /* Prevent it from shrinking */
        }

        .info-question b {
            font-weight: var(--font-weight-semibold);
            /* Ensure the number itself is bold */
        }

        .info-text {
            color: var(--color-dashboard-text-muted);
            line-height: var(--line-height-relaxed);
            /* Markdown rendering styles */
            word-wrap: break-word;
            /* Ensure long words wrap */
            flex-grow: 1;
            /* Allow text to take remaining space */
        }

        .info-text p,
        .info-text ul,
        .info-text ol,
        .info-text h1,
        .info-text h2,
        .info-text h3 {
            margin-bottom: 0em;
        }

        .info-text ul,
        .info-text ol {
            padding-left: var(--space-5);
        }

        .info-input {
            display: flex;
            gap: var(--space-3);
            align-items: center;
            flex-wrap: wrap;
            /* Pushes this to the bottom of the flex container */
            margin-top: auto;
            /* Push input to the bottom of additional-info */
        }

        .info-input input,
        .info-input textarea {
            font-size: 24px;
            /* Adjusted for better scale */
            padding: var(--space-3);
            border: 2px solid var(--color-border);
            border-radius: var(--radius);
            flex-grow: 1;
            /* Allow inputs to grow */
            height: 50px;
            /* Fixed height for input and textarea */
            box-shadow: var(--shadow-sm);
            transition: border-color var(--transition-fast);
            font-family: var(--font-family);
            background: var(--color-surface);
            color: var(--color-text);
        }

        .info-input input:focus,
        .info-input textarea:focus {
            border-color: var(--color-primary-500);
            /* Highlight on focus */
            outline: none;
            box-shadow: 0 0 0 3px var(--color-primary-50);
        }
        
        .info-input input:hover,
        .info-input textarea:hover {
            border-color: var(--color-text-muted);
        }

        /* No need for separate input height, textarea inherits */

        .info-input input:first-child {
            width: 150px;
            /* Fixed width for question number */
            flex-grow: 0;
            /* Prevent it from growing */
        }

        /* File Controls at bottom right */
        .file-controls {
            position: fixed;
            bottom: var(--space-5);
            right: var(--space-5);
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
            z-index: 3;
            /* Ensure it's above other content */
        }

        .file-input {
            display: none;
            /* Hide the default file input */
        }

        /* Animations */
        /* Removed .running animation for timer-section as requested */
        .warning {
            color: var(--color-error) !important;
            /* Important to override other colors */
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%,
            50% {
                opacity: 1;
            }

            51%,
            100% {
                opacity: 0.3;
            }
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Custom Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            /* Ensure it's on top of everything */
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.98);
            padding: var(--space-8);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            text-align: center;
            max-width: 500px;
            width: 90%;
            transform: scale(0.95);
            animation: fadeInScale 0.3s forwards;
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        .modal-title {
            font-size: 32px;
            color: var(--color-dashboard-text);
            margin-bottom: var(--space-3);
            font-weight: var(--font-weight-semibold);
            line-height: var(--line-height-tight);
        }

        .modal-message {
            font-size: 24px;
            color: var(--color-dashboard-text-muted);
            line-height: var(--line-height-relaxed);
        }

        .modal-content .btn-primary {
            align-self: center;
            margin-top: var(--space-3);
            padding: var(--space-3) var(--space-8);
            font-size: 24px;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .date-info {
                flex-direction: column;
                align-items: flex-start;
            }

            .date-display,
            .time-label,
            .time-value {
                font-size: 28px;
                /* Smaller font sizes for mobile */
            }

            .time-input {
                font-size: 24px;
                width: 100px;
            }

            .timer-row {
                flex-wrap: wrap;
                justify-content: center;
            }

            .timer-display {
                font-size: 80px;
                /* Smaller timer font */
            }

            .timer-label {
                font-size: 28px;
            }

            .btn {
                font-size: var(--font-size-lg);
                padding: var(--space-3) var(--space-5);
            }

            .info-input input,
            .info-input textarea {
                font-size: var(--font-size-lg);
                height: 40px;
                /* Adjusted fixed height for smaller screens */
            }

            .info-question,
            .info-text {
                font-size: var(--font-size-sm);
            }

            .progress-label {
                font-size: 30px;
            }

            .progress-tile {
                height: 14px;
                min-width: 8px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: var(--space-3);
                gap: var(--space-3);
            }

            .date-info,
            .timer-section,
            .additional-info {
                padding: var(--space-4);
            }

            .date-display,
            .time-label,
            .time-value {
                font-size: 24px;
            }

            .time-input {
                font-size: var(--font-size-lg);
                width: 90px;
            }

            .timer-display {
                font-size: 60px;
            }

            .timer-label {
                font-size: 24px;
            }

            .btn {
                font-size: var(--font-size-lg);
                padding: var(--space-2) var(--space-4);
            }

            .btn-small {
                font-size: var(--font-size-sm);
                padding: var(--space-2) var(--space-3);
            }

            .info-input {
                flex-direction: column;
                align-items: stretch;
            }

            .info-input input:first-child,
            .info-input input:nth-child(2) {
                width: 100%;
                /* Full width for inputs */
            }

            .file-controls {
                bottom: var(--space-3);
                right: var(--space-3);
                gap: var(--space-2);
            }

            .progress-label {
                font-size: 30px;
            }

            .progress-tile {
                height: 10px;
                min-width: 6px;
            }
        }

        input[type="time"]::-webkit-calendar-picker-indicator {
            background: transparent;
            bottom: 0;
            color: transparent;
            cursor: pointer;
            height: auto;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            width: auto
        }
    </style>
</head>

<body>
    <div class="overlay"></div>
    <div class="container">
        <!-- Date and Time Info -->
        <div class="date-info">
            <div class="date-display" id="dateDisplay"></div>
            <div class="time-info">
                <div class="time-label">Ende Prüfung:</div>
                <div class="time-value" id="examEndTime">--:--</div>
            </div>
            <div class="time-info">
                <div class="time-label">Ende Pause:</div>
                <input type="time" class="time-input" id="breakEndTime">
            </div>
        </div>

        <!-- Timer Section -->
        <div class="timer-section">
            <div class="timer-row">
                <button class="btn btn-success" id="startBtn" onclick="startTimer()">
                    <i class="bi bi-play-fill"></i></button>
                <div class="timer-label">Verbleibende Minuten</div>
                <div class="timer-display" id="timerDisplay" contenteditable="true" onclick="editTimer()">90</div>
            </div>
            <div class="progress-bar-container" id="progressBarContainer">
                <div class="progress-label" id="progressLabel"></div>
                <div class="progress-bar" id="progressBar"></div>
            </div>
        </div>

        <!-- Additional Information -->
        <div class="additional-info">
            <div class="info-display" id="infoDisplay"></div>
            <div class="info-input">
                <input type="text" id="questionNumber" placeholder="Aufg. Nr.">
                <textarea id="questionText" placeholder="Information zur Aufgabe..." rows="2"></textarea>
                <button class="btn btn-primary" onclick="addQuestionInfo()">Hinzufügen</button>
            </div>
        </div>
    </div>

    <!-- File Controls (moved to bottom right) -->
    <div class="file-controls">
        <button class="btn-small" onclick="resetAll()" title="Alles zurücksetzen"><i class="bi bi-arrow-counterclockwise"></i></button>
        <button class="btn-small" onclick="exportData()" title="Exportieren"><i class="bi bi-arrow-bar-down"></i></button>
        <button class="btn-small" onclick="document.getElementById('fileInput').click()" title="Importieren"><i
                class="bi bi-arrow-bar-up"></i></button>
        <input type="file" id="fileInput" class="file-input" accept=".json" onchange="importData(event)">
    </div>

    <!-- Custom Modal for messages -->
    <div id="customModal" class="modal-overlay" style="display:none;">
        <div class="modal-content">
            <h2 id="modalTitle" class="modal-title"></h2>
            <p id="modalMessage" class="modal-message"></p>
            <button class="btn btn-primary" onclick="hideMessage()">OK</button>
        </div>
    </div>

    <script>
        let timerInterval;
        let totalSeconds = 0;
        let remainingSeconds = 0;
        let isRunning = false;
        let questionInfos = [];
        let timerMinutes = 30;
        let examEndTimeString = '';
        let breakEndTimeManual = '';
        let breakEndTimeSetByUser = false;
        let totalQuestions = 0;
        let resizeTimeout;

        // Sanitize HTML: use DOMPurify if available, otherwise passthrough
        const sanitize = typeof DOMPurify !== 'undefined'
            ? (html) => DOMPurify.sanitize(html)
            : (html) => html;


        /**
         * Sets a random background image for the body.
         * Requires 'images' folder with '0.jpg' through '19.jpg' images.
         */
        function setRandomBackground() {
        const randomNum = Math.floor(Math.random() * 20);
            // Note: For this to work, you need an 'images' folder with files named 0.jpg, 1.jpg, ..., 19.jpg
            document.body.style.backgroundImage = `url('images/${randomNum}.jpg')`;
        }

        /**
         * Initializes the dashboard on load.
         * Sets background, updates date, loads data from storage, and updates displays.
         * Also sets up event listeners and initial layout adjustments.
         */
        function init() {
            setRandomBackground();
            parseUrlForTimer();
            updateDateDisplay();
            loadFromStorage();
            updateInfoDisplay();
            updateTimerDisplay();
            updateProgressBar();
            document.getElementById('breakEndTime').addEventListener('change', validateBreakEndTime);

            adjustLayout();

            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(adjustLayout, 200);
            });
        }

        /**
         * Adjusts the height of the info-display and its font size to fit the screen.
         */
        function adjustLayout() {
            adjustInfoDisplayHeight();
            // Call updateInfoDisplay to re-render with adjusted font size
            updateInfoDisplay();
        }

        /**
         * Parses the URL hash for 't' (timer minutes) and 'q' (question count) parameters.
         * Example: #t=90&q=10 or #t=90,q=10
         */
        function parseUrlForTimer() {
            const hash = window.location.hash;

            const timeMatch = hash.match(/[#&,]t=(\d+)/);
            if (timeMatch && timeMatch[1]) {
                const timeFromUrl = parseInt(timeMatch[1]);
                if (!isNaN(timeFromUrl) && timeFromUrl > 0 && timeFromUrl <= 300) {
                    timerMinutes = timeFromUrl;
                    remainingSeconds = timerMinutes * 60;
                    totalSeconds = timerMinutes * 60;
                }
            }

            const qMatch = hash.match(/[#&,]q=(\d+)/);
            if (qMatch && qMatch[1]) {
                const qFromUrl = parseInt(qMatch[1]);
                if (!isNaN(qFromUrl) && qFromUrl > 0 && qFromUrl <= 200) {
                    totalQuestions = qFromUrl;
                }
            }
        }

        /**
         * Allows editing of the timer display when clicked.
         * Selects the text for easy modification.
         */
        function editTimer() {
            const display = document.getElementById('timerDisplay');
            display.focus();

            const range = document.createRange();
            range.selectNodeContents(display);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        }

        /**
         * Event listener for the timerDisplay element.
         * Updates `timerMinutes` when the user finishes editing (blurs) the display.
         * Ensures only numbers are entered.
         */
        document.addEventListener('DOMContentLoaded', function () {
            const timerDisplay = document.getElementById('timerDisplay');

            timerDisplay.addEventListener('blur', function () {
                const value = parseInt(this.textContent) || 0;

                if (isRunning) {
                    // When running, treat edited value as new remaining minutes
                    const newRemainingMinutes = Math.max(0, Math.min(300, value));
                    const delta = (newRemainingMinutes * 60) - remainingSeconds;
                    remainingSeconds = newRemainingMinutes * 60;
                    totalSeconds = Math.max(1, totalSeconds + delta);
                    updateTimerDisplay();
                    updateEndTimes();
                    updateProgressBar();
                } else {
                    // When stopped, set initial timer value for next start
                    timerMinutes = Math.max(1, Math.min(300, value || 90));
                    this.textContent = timerMinutes;
                    totalSeconds = timerMinutes * 60;
                    remainingSeconds = totalSeconds;
                    updateTimerDisplay();
                }
                saveToStorage();
            });

            timerDisplay.addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    this.blur(); // Trigger blur to save changes on Enter key
                }
                // Allow only numeric input, plus Backspace, Delete, Arrow keys
                if (!/[0-9]/.test(e.key) && e.key !== 'Backspace' && e.key !== 'Delete' && e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') {
                    e.preventDefault(); // Prevent non-numeric input
                }
            });
        });

        /**
         * Updates the current date display (without year).
         */
        function updateDateDisplay() {
            const now = new Date();
            const dateStr = now.toLocaleDateString('de-DE', {
                day: '2-digit',
                month: '2-digit'
            });
            document.getElementById('dateDisplay').textContent = dateStr;
        }

        /**
         * Starts the timer countdown.
         * @param {boolean} isResumeFromLoad - If true, don't reset time (resuming after page reload)
         */
        function startTimer(isResumeFromLoad = false) {
            if (isRunning) return;

            if (!isResumeFromLoad) {
                totalSeconds = timerMinutes * 60;
                remainingSeconds = totalSeconds;
            }
            updateEndTimes();

            isRunning = true;
            document.getElementById('startBtn').style.display = 'none';

            timerInterval = setInterval(() => {
                if (remainingSeconds > 0) {
                    remainingSeconds--;
                    updateTimerDisplay();
                    updateProgressBar();
                } else {
                    timerEnded();
                }
            }, 1000);

            saveToStorage();
        }

        /**
         * Resets the timer to its initial `timerMinutes` value.
         */
        function resetTimer() {
            clearInterval(timerInterval);
            isRunning = false;

            totalSeconds = timerMinutes * 60;
            remainingSeconds = totalSeconds;
            updateTimerDisplay();

            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('timerDisplay').classList.remove('warning');

            clearEndTimes();
            saveToStorage();
        }

        /**
         * Updates the timer display based on `remainingSeconds`.
         * Shows "MM:SS" for last 3 minutes, otherwise just minutes.
         */
        function updateTimerDisplay() {
            const display = document.getElementById('timerDisplay');

            if (isRunning) {
                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = remainingSeconds % 60;

                if (remainingSeconds <= 180) { // 3 minutes (180 seconds) or less
                    display.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    if (remainingSeconds <= 60) {
                        display.classList.add('warning');
                    } else {
                        display.classList.remove('warning');
                    }
                } else {
                    display.textContent = `${minutes}`; // Display only minutes, no "Min"
                    display.classList.remove('warning');
                }
            } else {
                display.textContent = timerMinutes;
                display.classList.remove('warning');
            }
        }

        /**
         * Calculates and updates the exam end time.
         * Also suggests an initial break end time if not manually set.
         */
        function updateEndTimes() {
            const now = new Date();
            const examEnd = new Date(now.getTime() + remainingSeconds * 1000);

            examEndTimeString = examEnd.toLocaleTimeString('de-DE', {
                hour: '2-digit',
                minute: '2-digit',
                hourCycle: 'h23'
            });
            document.getElementById('examEndTime').textContent = examEndTimeString;

            if (!breakEndTimeSetByUser) { // Only auto-suggest if user hasn't manually set it
                const suggestedBreakEnd = new Date(examEnd.getTime() + 5 * 60 * 1000);
                document.getElementById('breakEndTime').value = suggestedBreakEnd.toLocaleTimeString('de-DE', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hourCycle: 'h23'
                });
                breakEndTimeManual = document.getElementById('breakEndTime').value;
            }
        }

        /**
         * Validates the manually entered break end time.
         */
        function validateBreakEndTime() {
            const breakTimeInput = document.getElementById('breakEndTime');
            const newBreakTimeString = breakTimeInput.value;

            if (newBreakTimeString) {
                // If exam hasn't started yet, any break time is valid
                if (!examEndTimeString) {
                    breakEndTimeManual = newBreakTimeString;
                    breakEndTimeSetByUser = true;
                    saveToStorage();
                    return;
                }

                const [breakHour, breakMinute] = newBreakTimeString.split(':').map(Number);
                const [examHour, examMinute] = examEndTimeString.split(':').map(Number);

                const now = new Date();
                const breakDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), breakHour, breakMinute);
                const examEndDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), examHour, examMinute);

                if (breakDate.getTime() > (examEndDate.getTime() + 1000)) {
                    breakEndTimeManual = newBreakTimeString;
                    breakEndTimeSetByUser = true;
                    saveToStorage();
                } else {
                    showMessage('Ungültige Zeit', 'Die Pause Ende Zeit muss nach der Prüfungsende Zeit liegen.');
                    breakTimeInput.value = breakEndTimeManual;
                }
            } else {
                breakEndTimeManual = '';
                breakEndTimeSetByUser = false;
                saveToStorage();
            }
        }

        /**
         * Clears the displayed exam and break end times.
         */
        function clearEndTimes() {
            document.getElementById('examEndTime').textContent = '--:--';
            document.getElementById('breakEndTime').value = '';
            examEndTimeString = '';
            breakEndTimeManual = '';
            breakEndTimeSetByUser = false;
        }

        /**
         * Handles actions when the timer reaches zero.
         */
        function timerEnded() {
            clearInterval(timerInterval);

            // Update progress bar while still "running" so all tiles show completed
            updateProgressBar();

            isRunning = false;

            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('timerDisplay').classList.remove('warning');

            playEndSound();
            showMessage('Zeit abgelaufen!', 'Die Prüfungszeit ist beendet. Gut gemacht!');
            clearEndTimes();
            saveToStorage();
        }

        /**
         * Plays a cheerful sound using the Web Audio API.
         */
        function playEndSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();

            const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5 (C major chord)

            frequencies.forEach((freq, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);

                oscillator.start(audioContext.currentTime + index * 0.15);
                oscillator.stop(audioContext.currentTime + index * 0.15 + 0.8);
            });
        }

        /**
         * Adds a new question information entry or updates an existing one.
         */
        function addQuestionInfo() {
            const questionNumber = document.getElementById('questionNumber').value.trim();
            const questionText = document.getElementById('questionText').value.trim();

            if (questionNumber && questionText) {
                questionInfos = questionInfos.filter(info => info.number !== questionNumber);
                questionInfos.push({
                    number: questionNumber,
                    text: questionText // Store raw markdown
                });

                questionInfos.sort((a, b) => {
                    const aNum = parseFloat(a.number.replace(/[^\d.]/g, '')) || 0;
                    const bNum = parseFloat(b.number.replace(/[^\d.]/g, '')) || 0;
                    return aNum - bNum;
                });

                updateInfoDisplay(); // Refresh the display and adjust font size
                saveToStorage();

                document.getElementById('questionNumber').value = '';
                document.getElementById('questionText').value = '';
            }
        }

        /**
         * Updates the display area for additional question information.
         * Applies Markdown rendering and dynamically adjusts font size.
         */
        function updateInfoDisplay() {
            const display = document.getElementById('infoDisplay');

            if (questionInfos.length === 0) {
                display.innerHTML = '<div style="font-size: 30px; color: #7f8c8d; text-align: center; padding: 40px;">Keine zusätzlichen Informationen vorhanden</div>';
                // Reset font size if no content
                display.querySelectorAll('.info-question, .info-text').forEach(el => el.style.fontSize = '');
                return;
            }

            // Render content with new "Aufg. X)" format
            display.innerHTML = questionInfos.map((info, index) => `
                <div class="info-item">
                    <div class="info-question">Aufg. <b>${sanitize(info.number)}</b>)</div>
                    <div class="info-text">${sanitize(marked.parse(info.text))}</div>
                    <button class="delete-btn" onclick="deleteQuestionInfo(${index})" title="Entfernen">
                        <i class="bi bi-x"></i>
                    </button>
                </div>
            `).join('');

            // Adjust font size after content is rendered and height is set
            adjustInfoDisplayFontSize();
        }

        /**
         * Adjusts the height of the info-display to fit available screen space.
         */
        function adjustInfoDisplayHeight() {
            const dateInfo = document.querySelector('.date-info');
            const timerSection = document.querySelector('.timer-section');
            const additionalInfo = document.querySelector('.additional-info');
            const infoInput = document.querySelector('.info-input');
            const container = document.querySelector('.container');

            const dateInfoHeight = dateInfo ? dateInfo.offsetHeight : 0;
            const timerSectionHeight = timerSection ? timerSection.offsetHeight : 0;
            const infoInputHeight = infoInput ? infoInput.offsetHeight : 0;

            const bodyStyle = getComputedStyle(document.body);
            const containerStyle = getComputedStyle(container);

            const bodyPaddingTop = parseFloat(bodyStyle.paddingTop);
            const bodyPaddingBottom = parseFloat(bodyStyle.paddingBottom);
            const containerPaddingTop = parseFloat(containerStyle.paddingTop);
            const containerPaddingBottom = parseFloat(containerStyle.paddingBottom);

            const containerGap = parseFloat(containerStyle.gap) || 12;
            const gridGaps = containerGap * 2;

            const totalFixedHeight = dateInfoHeight + timerSectionHeight + infoInputHeight +
                bodyPaddingTop + bodyPaddingBottom +
                containerPaddingTop + containerPaddingBottom +
                gridGaps;

            let availableHeight = window.innerHeight - totalFixedHeight;

            // Ensure a minimum height for usability (e.g., 100px)
            if (availableHeight < 100) {
                availableHeight = 100;
            }

            // Apply height to the info-display (the scrollable content area)
            document.getElementById('infoDisplay').style.height = `${availableHeight}px`;
        }

        /**
         * Dynamically adjusts the font size of content within info-display to fit.
         */
        function adjustInfoDisplayFontSize() {
            const infoDisplay = document.getElementById('infoDisplay');
            const infoItems = infoDisplay.querySelectorAll('.info-item');
            if (infoItems.length === 0) return;

            // Create a temporary div to measure content without affecting the visible layout
            const tempDiv = document.createElement('div');
            tempDiv.style.visibility = 'hidden';
            tempDiv.style.position = 'absolute';
            tempDiv.style.left = '-9999px';
            tempDiv.style.top = '-9999px';
            tempDiv.style.width = infoDisplay.clientWidth + 'px'; // Match width for accurate text wrapping
            tempDiv.style.height = 'auto'; // Auto height for content measurement
            tempDiv.style.overflow = 'hidden';
            document.body.appendChild(tempDiv);

            let minFontSize = 1; // Minimum readable font size
            let maxFontSize = 40; // Maximum desired font size for info-text
            let bestFitSize = minFontSize;

            let low = minFontSize;
            let high = maxFontSize;

            // Binary search to find the largest font size that fits
            while (low <= high) {
                let mid = Math.floor((low + high) / 2) | 0;

                tempDiv.innerHTML = ''; // Clear content for new measurement
                infoItems.forEach(item => {
                    const clonedItem = item.cloneNode(true);
                    // Apply trial font sizes
                    clonedItem.querySelector('.info-question').style.fontSize = `${mid}px`;
                    clonedItem.querySelector('.info-text').style.fontSize = `${mid}px`;
                    tempDiv.appendChild(clonedItem);
                });

                // Check if the content fits within the infoDisplay's clientHeight
                // clientHeight is the inner height of the element, excluding padding and border
                if (tempDiv.scrollHeight <= infoDisplay.clientHeight) {
                    bestFitSize = mid; // This size fits, try a larger one
                    low = mid + 1;
                } else {
                    high = mid - 1; // This size overflows, try a smaller one
                }
            }

            // Apply the best fit font size to the actual elements
            infoItems.forEach(item => {
                item.querySelector('.info-question').style.fontSize = `${bestFitSize}px`;
                item.querySelector('.info-text').style.fontSize = `${bestFitSize}px`;
            });

            document.body.removeChild(tempDiv); // Clean up the temporary div
        }


        /**
         * Sets the total question count and updates the progress bar.
         */
        function setQuestionCount(value) {
            totalQuestions = Math.max(0, Math.min(200, parseInt(value) || 0));
            updateProgressBar();
            saveToStorage();
        }

        /**
         * Updates the tiled progress bar based on elapsed time and total questions.
         */
        function updateProgressBar() {
            const container = document.getElementById('progressBarContainer');
            const bar = document.getElementById('progressBar');
            const label = document.getElementById('progressLabel');

            container.style.display = 'flex';

            let expectedQuestion = 0;
            if (isRunning && totalSeconds > 0 && totalQuestions > 0) {
                const elapsedSeconds = totalSeconds - remainingSeconds;
                expectedQuestion = Math.ceil((elapsedSeconds / totalSeconds) * totalQuestions);
                expectedQuestion = Math.max(1, Math.min(totalQuestions, expectedQuestion));
                if (elapsedSeconds === 0) expectedQuestion = 1;
            }

            // Build label with editable total
            const totalSpan = `<span class="progress-total" contenteditable="true" id="progressTotal">${totalQuestions}</span>`;
            label.innerHTML = isRunning
                ? `Aufgabe ${expectedQuestion} / ${totalSpan}`
                : `${totalSpan} Aufgaben`;

            // Add event listener for editing the total
            const totalEl = document.getElementById('progressTotal');
            if (totalEl) {
                totalEl.addEventListener('blur', function() {
                    const newVal = parseInt(this.textContent) || 0;
                    if (newVal !== totalQuestions) {
                        setQuestionCount(newVal);
                    }
                });
                totalEl.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.blur();
                    }
                });
            }

            bar.innerHTML = '';
            for (let i = 1; i <= totalQuestions; i++) {
                const tile = document.createElement('div');
                tile.className = 'progress-tile';
                if (isRunning) {
                    if (i < expectedQuestion) {
                        tile.classList.add('completed');
                    } else if (i === expectedQuestion) {
                        // If time is fully elapsed, mark as completed instead of current
                        if (remainingSeconds === 0) {
                            tile.classList.add('completed');
                        } else {
                            tile.classList.add('current');
                        }
                    }
                }
                bar.appendChild(tile);
            }
        }

        /**
         * Deletes a question info item by index.
         */
        function deleteQuestionInfo(index) {
            if (index >= 0 && index < questionInfos.length) {
                questionInfos.splice(index, 1);
                updateInfoDisplay();
                saveToStorage();
            }
        }

        /**
         * Resets the entire dashboard for a new exam.
         */
        function resetAll() {
            clearInterval(timerInterval);

            isRunning = false;
            timerMinutes = 90;
            totalSeconds = timerMinutes * 60;
            remainingSeconds = totalSeconds;
            questionInfos = [];
            examEndTimeString = '';
            breakEndTimeManual = '';
            breakEndTimeSetByUser = false;
            totalQuestions = 0;

            try {
                localStorage.removeItem('examDashboard');
            } catch (e) {
                console.warn('Could not clear localStorage:', e);
            }

            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('timerDisplay').classList.remove('warning');
            document.getElementById('examEndTime').textContent = '--:--';
            document.getElementById('breakEndTime').value = '';

            parseUrlForTimer();

            updateTimerDisplay();
            updateInfoDisplay();
            updateProgressBar();
        }

        /**
         * Saves the current application state to localStorage.
         */
        function saveToStorage() {
            const data = {
                questionInfos: questionInfos,
                timerMinutes: timerMinutes,
                remainingSeconds: remainingSeconds,
                totalSeconds: totalSeconds,
                isRunning: isRunning,
                breakEndTimeManual: breakEndTimeManual,
                breakEndTimeSetByUser: breakEndTimeSetByUser,
                examEndTimeString: examEndTimeString,
                totalQuestions: totalQuestions,
                savedAt: Date.now()
            };
            try {
                localStorage.setItem('examDashboard', JSON.stringify(data));
            } catch (e) {
                console.warn('Could not save to localStorage:', e);
            }
        }

        /**
         * Loads the application state from localStorage.
         * Prioritizes URL hash for initial timer setting if present.
         */
        function loadFromStorage() {
            let data;
            try {
                const stored = localStorage.getItem('examDashboard');
                if (stored) data = JSON.parse(stored);
            } catch (e) {
                console.warn('Could not load from localStorage:', e);
                return;
            }
            if (!data) return;

            questionInfos = data.questionInfos || [];
            totalQuestions = data.totalQuestions || 0;

            const urlTimerSet = window.location.hash.indexOf('#t=') !== -1;
            if (!urlTimerSet || data.isRunning) {
                timerMinutes = data.timerMinutes !== undefined ? data.timerMinutes : 90;
                totalSeconds = data.totalSeconds !== undefined ? data.totalSeconds : timerMinutes * 60;
                remainingSeconds = data.remainingSeconds !== undefined ? data.remainingSeconds : timerMinutes * 60;
                isRunning = data.isRunning || false;

                // If timer was running when saved, subtract elapsed time since save
                if (isRunning && data.savedAt) {
                    const elapsedSinceSave = Math.floor((Date.now() - data.savedAt) / 1000);
                    remainingSeconds = Math.max(0, remainingSeconds - elapsedSinceSave);
                }
            }

            breakEndTimeManual = data.breakEndTimeManual || '';
            breakEndTimeSetByUser = data.breakEndTimeSetByUser || false;
            examEndTimeString = data.examEndTimeString || '';

            document.getElementById('breakEndTime').value = breakEndTimeManual;
            document.getElementById('examEndTime').textContent = examEndTimeString || '--:--';

            if (isRunning) {
                if (remainingSeconds <= 0) {
                    timerEnded();
                } else {
                    startTimer(true);
                }
            } else {
                updateTimerDisplay();
            }
        }

        /**
         * Exports the current application data as a JSON file.
         */
        function exportData() {
            const data = {
                questionInfos: questionInfos,
                timerMinutes: timerMinutes,
                remainingSeconds: remainingSeconds,
                totalSeconds: totalSeconds,
                isRunning: isRunning,
                breakEndTimeManual: breakEndTimeManual,
                examEndTimeString: examEndTimeString,
                totalQuestions: totalQuestions,
                exportDate: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `exam-dashboard-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        /**
         * Imports data from a selected JSON file, updating the dashboard state.
         */
        function importData(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.questionInfos) {
                            questionInfos = data.questionInfos;
                        }

                        if (data.timerMinutes !== undefined) {
                            timerMinutes = data.timerMinutes;
                            totalSeconds = data.totalSeconds !== undefined ? data.totalSeconds : data.timerMinutes * 60;
                            remainingSeconds = data.remainingSeconds !== undefined ? data.remainingSeconds : data.timerMinutes * 60;
                            isRunning = data.isRunning || false;
                            breakEndTimeManual = data.breakEndTimeManual || '';
                            examEndTimeString = data.examEndTimeString || '';
                            totalQuestions = data.totalQuestions || 0;

                            document.getElementById('breakEndTime').value = breakEndTimeManual;
                            document.getElementById('examEndTime').textContent = examEndTimeString || '--:--';

                            clearInterval(timerInterval);

                            if (isRunning) {
                                startTimer();
                            } else {
                                updateTimerDisplay();
                                document.getElementById('startBtn').style.display = 'inline-block';
                            }
                        }
                        saveToStorage();
                        updateInfoDisplay(); // Refresh info display (calls font size adjustment)
                        showMessage('Import Erfolgreich', 'Die Daten wurden erfolgreich importiert.');
                    } catch (error) {
                        showMessage('Import Fehler', 'Fehler beim Importieren der Datei: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
        }

        document.getElementById('questionText').addEventListener('keypress', function (e) {
            if (e.key === 'Enter' && !e.shiftKey) { // Allow Shift+Enter for new lines in textarea
                e.preventDefault(); // Prevent default new line behavior for Enter
                addQuestionInfo();
            }
        });

        window.addEventListener('load', init);

        function showMessage(title, message) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;
            document.getElementById('customModal').style.display = 'flex';
        }

        function hideMessage() {
            document.getElementById('customModal').style.display = 'none';
        }
    </script>
</body>

</html>
