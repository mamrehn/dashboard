<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pr√ºfungs-Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css">
    <style>
        /* === Design Tokens === */
        :root {
          /* Colors - Primary (seaborn green) */
          --color-primary-500: #2ca02c;
          --color-primary-600: #238c23;
          --color-primary-700: #1a6b1a;
          --color-primary-50: #f0f9f0;
          --color-primary-100: #d4f1d4;
          
          /* Colors - Semantic (seaborn palette) */
          --color-success: #2ca02c;
          --color-error: #d62728;
          --color-warning: #ff7f0e;
          --color-info: #1f77b4;
          
          /* Colors - Neutral */
          --color-surface: #ffffff;
          --color-bg: #f6f7f8;
          --color-text: #1f2d33;
          --color-text-muted: #8e98a1;
          --color-border: #e3e7ea;
          --color-hover: #f0f2f3;
          
          /* Dashboard specific colors (darker for readability on background) */
          --color-dashboard-text: #2c3e50;
          --color-dashboard-text-muted: #34495e;
          
          /* Spacing Scale */
          --space-1: 4px;
          --space-2: 8px;
          --space-3: 12px;
          --space-4: 16px;
          --space-5: 20px;
          --space-6: 24px;
          --space-8: 32px;
          
          /* Typography */
          --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
          --font-size-sm: 14px;
          --font-size-base: 15px;
          --font-size-lg: 18px;
          --font-size-xl: 20px;
          --font-weight-normal: 400;
          --font-weight-medium: 500;
          --font-weight-semibold: 600;
          --line-height-tight: 1.3;
          --line-height-normal: 1.5;
          --line-height-relaxed: 1.6;
          
          /* Border Radius */
          --radius-sm: 4px;
          --radius: 6px;
          --radius-lg: 8px;
          
          /* Shadows */
          --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
          --shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
          --shadow-md: 0 2px 6px rgba(0, 0, 0, 0.15);
          --shadow-lg: 0 4px 12px rgba(0, 0, 0, 0.2);
          
          /* Transitions */
          --transition-fast: 150ms ease;
          --transition-base: 200ms ease;
          --transition-slow: 300ms ease;
        }

        /* General Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Focus styles for accessibility */
        *:focus-visible {
          outline: 2px solid var(--color-primary-500);
          outline-offset: 2px;
        }

        /* Body and Background Styling */
        body {
            font-family: var(--font-family);
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            height: 100vh;
            /* Prevent body from scrolling */
            overflow: hidden;
            position: relative;
            font-size: var(--font-size-base);
            font-weight: var(--font-weight-normal);
            line-height: var(--line-height-normal);
            color: var(--color-dashboard-text);
        }

        /* Overlay for background effect */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 1;
        }

        /* Main Container for Dashboard Layout */
        .container {
            position: relative;
            z-index: 2;
            padding: var(--space-5);
            display: flex;
            /* Use flexbox for a column layout */
            flex-direction: column;
            /* Occupy full viewport height */
            height: 100vh;
            gap: var(--space-3);
            /* Spacing between sections */
            max-width: 90%;
            width: 100%;
            /* Center the container */
            margin: 0 auto;
            border-radius: var(--radius-lg);
            overflow: hidden;
        }

        /* Shared Card Styling */
        .date-info,
        .timer-section,
        .additional-info {
            background: rgba(255, 255, 255, 0.95);
            /* Slightly transparent white background */
            border-radius: var(--radius-lg);
            /* Rounded corners for individual cards */
            padding: var(--space-4) var(--space-6);
            /* Padding inside cards */
            box-shadow: var(--shadow-lg);
            /* Soft shadow */
            backdrop-filter: blur(10px);
            /* Frosted glass effect */
            border: 1px solid rgba(255, 255, 255, 0.2);
            /* Subtle border */
            transition: all var(--transition-base);
        }
        
        .date-info:hover,
        .timer-section:hover,
        .additional-info:hover {
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        /* Date and Time Info Section (ROW 1 - FIXED HEIGHT) */
        .date-info {
            /* This row will not grow or shrink; its height is based on its content. */
            flex: 0 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            /* Allow wrapping on smaller screens */
            gap: var(--space-3);
            /* Spacing between date and time elements */
        }

        .date-display {
            font-size: 36px;
            font-weight: var(--font-weight-semibold);
            color: var(--color-dashboard-text);
            line-height: var(--line-height-tight);
        }

        .time-info {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .time-label {
            font-size: 30px;
            /* Adjusted for better readability */
            color: var(--color-text-muted);
            font-weight: var(--font-weight-medium);
        }

        .time-value {
            font-size: 36px;
            font-weight: var(--font-weight-semibold);
            color: var(--color-dashboard-text);
            line-height: var(--line-height-tight);
        }

        .time-input {
            font-size: 30px;
            /* Match label font size */
            padding: var(--space-2) var(--space-3);
            border: 2px solid var(--color-border);
            border-radius: var(--radius);
            width: 120px;
            /* Fixed width for time input */
            text-align: center;
            font-family: var(--font-family);
            transition: border-color var(--transition-fast);
            background: var(--color-surface);
        }
        
        .time-input:hover {
            border-color: var(--color-text-muted);
        }
        
        .time-input:focus {
            border-color: var(--color-primary-500);
            outline: none;
            box-shadow: 0 0 0 3px var(--color-primary-50);
        }

        /* Timer Section (ROW 2 - FIXED HEIGHT) */
        .timer-section {
            /* This row will also not grow or shrink. */
            flex: 0 0 auto;
            display: flex;
            /* Make it a flex container to arrange its children */
            justify-content: space-around;
            /* Distribute space between left and right panels */
            align-items: center;
            /* Vertically align items */
            gap: var(--space-3);
            /* Space between the two panels */
            padding: var(--space-4) var(--space-6);
            flex-wrap: wrap;
            /* Allow panels to wrap on smaller screens */
        }

        .timer-left-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Center content within left panel */
            gap: var(--space-3);
            /* Space between label and controls */
            flex-grow: 1;
            /* Allow it to grow */
            flex-basis: 45%;
            /* Start with roughly half the width, leaving room for gap */
            min-width: 200px;
            /* Ensure it doesn't get too small */
            text-align: center;
            /* Center the label text */
        }

        .timer-right-panel {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            /* Allow it to grow */
            flex-basis: 45%;
            /* Start with roughly half the width */
            min-width: 200px;
            /* Ensure it doesn't get too small */
        }

        .timer-label {
            font-size: 36px;
            color: var(--color-dashboard-text-muted);
            font-weight: var(--font-weight-semibold);
            line-height: var(--line-height-tight);
        }

        .timer-display {
            font-size: 120px;
            font-weight: var(--font-weight-semibold);
            color: var(--color-dashboard-text);
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            /* Monospaced font for timer */
            min-height: 1.2em;
            /* Ensure consistent height for editable content */
            border: 2px solid transparent;
            /* Transparent border for editing */
            /*padding: 5px 10px;*/
            border-radius: var(--radius);
            transition: border-color var(--transition-fast);
            cursor: pointer;
            line-height: var(--line-height-tight);
        }

        .timer-display:focus {
            border-color: var(--color-primary-500);
            /* Highlight border on focus */
            outline: none;
            background: rgba(255, 255, 255, 0.8);
        }

        /* Timer Controls (Buttons inside Timer Section) */
        .timer-controls {
            display: flex;
            gap: var(--space-3);
            /* Spacing between buttons */
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            /* Allow buttons to wrap */
        }

        /* === Buttons === */
        .btn,
        .btn-small {
            padding: var(--space-3) var(--space-6);
            border: none;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-medium);
            font-family: var(--font-family);
            transition: all var(--transition-fast);
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            line-height: var(--line-height-normal);
        }
        
        .btn:hover,
        .btn-small:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .btn:active,
        .btn-small:active {
            transform: translateY(0);
        }

        /* Button Icon Styling */
        .btn span,
        .btn-small span {
            font-size: 1.5em;
            /* Make symbol a bit larger than button text */
            line-height: 1;
            /* Ensure vertical centering */
            color: inherit;
            /* Inherit color from parent button */
        }

        .btn-primary {
            background: var(--color-primary-500);
            color: white;
        }

        .btn-primary:hover {
            background: var(--color-primary-600);
        }

        .btn-primary:active {
            background: var(--color-primary-700);
        }

        .btn-success {
            background: var(--color-success);
            color: white;
        }

        .btn-success:hover {
            background: var(--color-primary-600);
        }

        .btn-warning {
            background: var(--color-warning);
            color: white;
        }

        .btn-warning:hover {
            background: #e6720e;
        }

        /* Small Buttons (for file controls) */
        .btn-small {
            font-size: var(--font-size-base);
            padding: var(--space-2) var(--space-4);
            border-radius: var(--radius);
            box-shadow: var(--shadow-sm);
            background: var(--color-surface);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }
        
        .btn-small:hover {
            background: var(--color-hover);
            border-color: var(--color-text-muted);
        }

        /* Additional Information Section (ROW 3 - FILLS REMAINING SPACE) */
        .additional-info {
            /* This row will grow to fill all available vertical space. */
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            /* Hide this container's overflow; the inner .info-display will scroll. */
            overflow: hidden;
        }

        .info-display {
            /* Takes remaining space inside its parent */
            flex: 1;
            /* Takes remaining space */
            margin-bottom: var(--space-5);
            /* Enable scrolling for overflowing content */
            overflow-y: auto;
            /* Enable scrolling for overflowing content */
            padding-right: var(--space-3);
            /* Padding for scrollbar */
            /* height will be set by JS */
        }

        .info-item {
            margin-bottom: 0.1em;
            padding: var(--space-3);
            background: var(--color-surface);
            border-radius: var(--radius);
            border: 1px solid var(--color-border);
            box-shadow: var(--shadow-sm);
            display: flex;
            /* Use flexbox for "Aufgabe X)" and text */
            align-items: baseline;
            /* Align items to their baselines */
            gap: var(--space-3);
            /* Space between label and text */
            transition: all var(--transition-fast);
        }
        
        .info-item:hover {
            box-shadow: var(--shadow);
            border-color: var(--color-primary-500);
        }

        .info-question {
            font-weight: var(--font-weight-semibold);
            color: var(--color-dashboard-text);
            flex-shrink: 0;
            /* Prevent it from shrinking */
        }

        .info-question b {
            font-weight: var(--font-weight-semibold);
            /* Ensure the number itself is bold */
        }

        .info-text {
            color: var(--color-dashboard-text-muted);
            line-height: var(--line-height-relaxed);
            /* Markdown rendering styles */
            word-wrap: break-word;
            /* Ensure long words wrap */
            flex-grow: 1;
            /* Allow text to take remaining space */
        }

        .info-text p,
        .info-text ul,
        .info-text ol,
        .info-text h1,
        .info-text h2,
        .info-text h3 {
            margin-bottom: 0em;
        }

        .info-text ul,
        .info-text ol {
            padding-left: var(--space-5);
        }

        .info-input {
            display: flex;
            gap: var(--space-3);
            align-items: center;
            flex-wrap: wrap;
            /* Pushes this to the bottom of the flex container */
            margin-top: auto;
            /* Push input to the bottom of additional-info */
        }

        .info-input input,
        .info-input textarea {
            font-size: 24px;
            /* Adjusted for better scale */
            padding: var(--space-3);
            border: 2px solid var(--color-border);
            border-radius: var(--radius);
            flex-grow: 1;
            /* Allow inputs to grow */
            height: 50px;
            /* Fixed height for input and textarea */
            box-shadow: var(--shadow-sm);
            transition: border-color var(--transition-fast);
            font-family: var(--font-family);
            background: var(--color-surface);
            color: var(--color-text);
        }

        .info-input input:focus,
        .info-input textarea:focus {
            border-color: var(--color-primary-500);
            /* Highlight on focus */
            outline: none;
            box-shadow: 0 0 0 3px var(--color-primary-50);
        }
        
        .info-input input:hover,
        .info-input textarea:hover {
            border-color: var(--color-text-muted);
        }

        /* No need for separate input height, textarea inherits */

        .info-input input:first-child {
            width: 150px;
            /* Fixed width for question number */
            flex-grow: 0;
            /* Prevent it from growing */
        }

        /* File Controls at bottom right */
        .file-controls {
            position: fixed;
            bottom: var(--space-5);
            right: var(--space-5);
            display: flex;
            gap: var(--space-3);
            z-index: 3;
            /* Ensure it's above other content */
        }

        .file-input {
            display: none;
            /* Hide the default file input */
        }

        /* Animations */
        /* Removed .running animation for timer-section as requested */
        .warning {
            color: var(--color-error) !important;
            /* Important to override other colors */
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%,
            50% {
                opacity: 1;
            }

            51%,
            100% {
                opacity: 0.3;
            }
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Custom Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            /* Ensure it's on top of everything */
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.98);
            padding: var(--space-8);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            text-align: center;
            max-width: 500px;
            width: 90%;
            transform: scale(0.95);
            animation: fadeInScale 0.3s forwards;
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        .modal-title {
            font-size: 32px;
            color: var(--color-dashboard-text);
            margin-bottom: var(--space-3);
            font-weight: var(--font-weight-semibold);
            line-height: var(--line-height-tight);
        }

        .modal-message {
            font-size: 24px;
            color: var(--color-dashboard-text-muted);
            line-height: var(--line-height-relaxed);
        }

        .modal-content .btn-primary {
            align-self: center;
            margin-top: var(--space-3);
            padding: var(--space-3) var(--space-8);
            font-size: 24px;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .date-info {
                flex-direction: column;
                align-items: flex-start;
            }

            .date-display,
            .time-label,
            .time-value {
                font-size: 28px;
                /* Smaller font sizes for mobile */
            }

            .time-input {
                font-size: 24px;
                width: 100px;
            }

            .timer-section {
                flex-direction: column;
                /* Stack panels vertically on smaller screens */
                align-items: center;
                justify-content: center;
            }

            .timer-left-panel,
            .timer-right-panel {
                flex-basis: 100%;
                /* Full width for panels */
                min-width: unset;
                /* Remove min-width constraint */
            }

            .timer-display {
                font-size: 80px;
                /* Smaller timer font */
            }

            .timer-label {
                font-size: 28px;
            }

            .btn {
                font-size: var(--font-size-lg);
                padding: var(--space-3) var(--space-5);
            }

            .info-input input,
            .info-input textarea {
                font-size: var(--font-size-lg);
                height: 40px;
                /* Adjusted fixed height for smaller screens */
            }

            .info-question,
            .info-text {
                font-size: var(--font-size-sm);
                /* Adjusted font size dynamically */
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: var(--space-3);
                gap: var(--space-3);
            }

            .date-info,
            .timer-section,
            .additional-info {
                padding: var(--space-4);
            }

            .date-display,
            .time-label,
            .time-value {
                font-size: 24px;
            }

            .time-input {
                font-size: var(--font-size-lg);
                width: 90px;
            }

            .timer-display {
                font-size: 60px;
            }

            .timer-label {
                font-size: 24px;
            }

            .btn {
                font-size: var(--font-size-lg);
                padding: var(--space-2) var(--space-4);
            }

            .btn-small {
                font-size: var(--font-size-sm);
                padding: var(--space-2) var(--space-3);
            }

            .info-input {
                flex-direction: column;
                align-items: stretch;
            }

            .info-input input:first-child,
            .info-input input:nth-child(2) {
                width: 100%;
                /* Full width for inputs */
            }

            .file-controls {
                bottom: var(--space-3);
                right: var(--space-3);
                gap: var(--space-2);
            }
        }

        input[type="time"]::-webkit-calendar-picker-indicator {
            background: transparent;
            bottom: 0;
            color: transparent;
            cursor: pointer;
            height: auto;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            width: auto
        }
    </style>
</head>

<body>
    <div class="overlay"></div>
    <div class="container">
        <!-- Date and Time Info -->
        <div class="date-info">
            <div class="date-display" id="dateDisplay"></div>
            <div class="time-info">
                <div class="time-label">Ende Pr√ºfung:</div>
                <div class="time-value" id="examEndTime">--:--</div>
            </div>
            <div class="time-info">
                <div class="time-label">Ende Pause:</div>
                <input type="time" class="time-input" id="breakEndTime">
            </div>
        </div>

        <!-- Timer Section -->
        <div class="timer-section">
            <div class="timer-left-panel">
                <div class="timer-label">Verbleibende Minuten</div>
                <div class="timer-controls">
                    <button class="btn btn-success" id="startBtn" onclick="startTimer()">
                        <i class="bi bi-play-fill"></i></button>
                    <button class="btn btn-warning" id="pauseBtn" onclick="pauseTimer()" style="display: none;">
                        <i class="bi bi-pause-fill"></i></button>
                    <!--<button class="btn btn-primary" onclick="resetTimer()"><i class="bi bi-arrow-clockwise"></i></button>-->
                </div>
            </div>
            <div class="timer-right-panel">
                <div class="timer-display" id="timerDisplay" contenteditable="true" onclick="editTimer()">90</div>
            </div>
        </div>

        <!-- Additional Information -->
        <div class="additional-info">
            <div class="info-display" id="infoDisplay"></div>
            <div class="info-input">
                <input type="text" id="questionNumber" placeholder="Aufg. Nr.">
                <textarea id="questionText" placeholder="Information zur Aufgabe..." rows="2"></textarea>
                <button class="btn btn-primary" onclick="addQuestionInfo()">Hinzuf√ºgen</button>
            </div>
        </div>
    </div>

    <!-- File Controls (moved to bottom right) -->
    <div class="file-controls">
        <button class="btn-small" onclick="exportData()"><i class="bi bi-arrow-bar-down"></i></button>
        <button class="btn-small" onclick="document.getElementById('fileInput').click()"><i
                class="bi bi-arrow-bar-up"></i></button>
        <input type="file" id="fileInput" class="file-input" accept=".json" onchange="importData(event)">
    </div>

    <!-- Custom Modal for messages -->
    <div id="customModal" class="modal-overlay" style="display:none;">
        <div class="modal-content">
            <h2 id="modalTitle" class="modal-title"></h2>
            <p id="modalMessage" class="modal-message"></p>
            <button class="btn btn-primary" onclick="hideMessage()">OK</button>
        </div>
    </div>

    <script>
        let timerInterval;
        let totalSeconds = 0;
        let remainingSeconds = 0;
        let isRunning = false;
        let isPaused = false;
        let questionInfos = [];
        let timerMinutes = 30; // Initial timer value in minutes
        let examEndTimeString = ''; // To store the formatted exam end time for validation
        let breakEndTimeManual = ''; // To store the manually set break end time
        let resizeTimeout; // For debouncing window resize event


        function textFill() {
            const tf = document.querySelector('.textFill');
            const parent = tf.parentElement;
            let i = 1;

            tf.style.fontSize = i + 'px';

            while (true) {
                tf.style.fontSize = i + 'px';
                const scrollWidth = tf.scrollWidth;
                const scrollHeight = tf.scrollHeight;
                const clientWidth = tf.clientWidth;
                const clientHeight = tf.clientHeight;

                const parentHeight = parent.clientHeight;

                if (scrollHeight > parentHeight || scrollWidth > clientWidth) {
                    break;
                }
                i++;
            }

            tf.style.fontSize = (i - 1) + 'px';
        }


        /**
         * Sets a random background image for the body.
         * Requires 'images' folder with '1.pmg' through '10.png' images.
         */
        function setRandomBackground() {
            const randomNum = Math.floor(Math.random() * 1) + 1;
            // Note: For this to work, you need an 'images' folder with files named 1.jpg, 2.jpg, ..., 10.jpg
            document.body.style.backgroundImage = `url('images/${randomNum}.png')`; // Placeholder for demo
        }

        /**
         * Initializes the dashboard on load.
         * Sets background, updates date, loads data from storage, and updates displays.
         * Also sets up event listeners and initial layout adjustments.
         */
        function init() {
            setRandomBackground();
            parseUrlForTimer(); // Check URL hash for initial timer value
            updateDateDisplay();
            loadFromStorage(); // Load saved data (overrides URL if saved data has active timer state, otherwise URL sets initial value)
            updateInfoDisplay(); // This will also call adjustInfoDisplayFontSize() internally
            updateTimerDisplay(); // Ensure timer display shows initial value
            document.getElementById('breakEndTime').addEventListener('change', validateBreakEndTime);

            // Initial layout adjustments
            adjustLayout();

            // Event listener for window resize, debounced
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(adjustLayout, 200); // Debounce by 200ms
            });
        }

        /**
         * Adjusts the height of the info-display and its font size to fit the screen.
         */
        function adjustLayout() {
            adjustInfoDisplayHeight();
            // Call updateInfoDisplay to re-render with adjusted font size
            updateInfoDisplay();
        }

        /**
         * Parses the URL hash for a 't' parameter to set the initial timer minutes.
         * Example: #t=13 sets timer to 13 minutes.
         */
        function parseUrlForTimer() {
            const hash = window.location.hash;
            const match = hash.match(/#t=(\d+)/);
            if (match && match[1]) {
                const timeFromUrl = parseInt(match[1]);
                // Validate time: must be a number, greater than 0, and within a reasonable range (e.g., up to 300 minutes)
                if (!isNaN(timeFromUrl) && timeFromUrl > 0 && timeFromUrl <= 300) {
                    timerMinutes = timeFromUrl;
                    // Also reset remaining seconds if a new URL timer is set
                    remainingSeconds = timerMinutes * 60;
                    totalSeconds = timerMinutes * 60;
                }
            }
        }

        /**
         * Allows editing of the timer display when clicked.
         * Selects the text for easy modification.
         */
        function editTimer() {
            if (!isRunning) {
                const display = document.getElementById('timerDisplay');
                display.focus();

                // Select all text in the contenteditable div
                const range = document.createRange();
                range.selectNodeContents(display);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
            }
        }

        /**
         * Event listener for the timerDisplay element.
         * Updates `timerMinutes` when the user finishes editing (blurs) the display.
         * Ensures only numbers are entered.
         */
        document.addEventListener('DOMContentLoaded', function () {
            const timerDisplay = document.getElementById('timerDisplay');

            timerDisplay.addEventListener('blur', function () {
                const oldTimerMinutes = timerMinutes; // Capture old value before updating
                const value = parseInt(this.textContent) || 90;
                timerMinutes = Math.max(1, Math.min(300, value));
                this.textContent = timerMinutes; // Update display to clean value

                // Calculate difference in seconds
                const minuteDifferenceInSeconds = (timerMinutes - oldTimerMinutes) * 60;

                // Adjust remaining seconds only if timer was active
                if (isRunning || isPaused) {
                    remainingSeconds += minuteDifferenceInSeconds;
                    if (remainingSeconds < 0) remainingSeconds = 0; // Prevent negative time
                    updateTimerDisplay(); // Immediately reflect new time
                    updateEndTimes(); // Adjust end times
                } else {
                    // If not running/paused, just update totalSeconds for next start
                    totalSeconds = timerMinutes * 60;
                    remainingSeconds = totalSeconds;
                    updateTimerDisplay(); // Make sure initial display is correct (e.g., after loading)
                }
                saveToStorage(); // Save the new timerMinutes and state
            });

            timerDisplay.addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    this.blur(); // Trigger blur to save changes on Enter key
                }
                // Allow only numeric input, plus Backspace, Delete, Arrow keys
                if (!/[0-9]/.test(e.key) && e.key !== 'Backspace' && e.key !== 'Delete' && e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') {
                    e.preventDefault(); // Prevent non-numeric input
                }
            });
        });

        /**
         * Updates the current date display (without year).
         */
        function updateDateDisplay() {
            const now = new Date();
            const dateStr = now.toLocaleDateString('de-DE', {
                day: '2-digit',
                month: '2-digit'
            });
            document.getElementById('dateDisplay').textContent = dateStr;
        }

        /**
         * Starts the timer countdown.
         */
        function startTimer() {
            if (!isRunning && !isPaused) {
                totalSeconds = timerMinutes * 60;
                remainingSeconds = totalSeconds;
                updateEndTimes(); // Calculate and display exam end time, update break end time if needed
            }

            isRunning = true;
            isPaused = false;

            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'inline-block';

            timerInterval = setInterval(() => {
                if (remainingSeconds > 0) {
                    remainingSeconds--;
                    updateTimerDisplay();
                } else {
                    timerEnded(); // Timer finished
                }
            }, 1000);

            saveToStorage(); // Save state when timer starts
        }

        /**
         * Pauses the running timer.
         */
        function pauseTimer() {
            if (isRunning) {
                clearInterval(timerInterval); // Stop the interval
                isRunning = false;
                isPaused = true;

                document.getElementById('startBtn').style.display = 'inline-block';
                document.getElementById('pauseBtn').style.display = 'none';

                saveToStorage(); // Save state when timer pauses
            }
        }

        /**
         * Resets the timer to its initial `timerMinutes` value.
         */
        function resetTimer() {
            clearInterval(timerInterval); // Stop any running interval
            isRunning = false;
            isPaused = false;

            totalSeconds = timerMinutes * 60;
            remainingSeconds = totalSeconds;
            updateTimerDisplay(); // Update display to reflect reset

            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('pauseBtn').style.display = 'none';

            document.getElementById('timerDisplay').classList.remove('warning');

            clearEndTimes(); // Clear displayed end times
            saveToStorage(); // Save state after reset
        }

        /**
         * Updates the timer display based on `remainingSeconds`.
         * Shows "MM:SS" for last 3 minutes, otherwise just minutes.
         */
        function updateTimerDisplay() {
            const display = document.getElementById('timerDisplay');

            if (isRunning || isPaused) {
                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = remainingSeconds % 60;

                if (remainingSeconds <= 180) { // 3 minutes (180 seconds) or less
                    display.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    if (remainingSeconds <= 60) {
                        display.classList.add('warning');
                    } else {
                        display.classList.remove('warning');
                    }
                } else {
                    display.textContent = `${minutes}`; // Display only minutes, no "Min"
                    display.classList.remove('warning');
                }
            } else {
                display.textContent = timerMinutes;
                display.classList.remove('warning');
            }
        }

        /**
         * Calculates and updates the exam end time.
         * Also suggests an initial break end time if not manually set.
         */
        function updateEndTimes() {
            const now = new Date();
            const examEnd = new Date(now.getTime() + remainingSeconds * 1000);

            examEndTimeString = examEnd.toLocaleTimeString('de-DE', {
                hour: '2-digit',
                minute: '2-digit',
                hourCycle: 'h23'
            });
            document.getElementById('examEndTime').textContent = examEndTimeString;

            if (!breakEndTimeManual || isRunning || isPaused) { // Only auto-suggest if not manually set or timer is active
                const suggestedBreakEnd = new Date(examEnd.getTime() + 5 * 60 * 1000);
                document.getElementById('breakEndTime').value = suggestedBreakEnd.toLocaleTimeString('de-DE', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hourCycle: 'h23'
                });
                breakEndTimeManual = document.getElementById('breakEndTime').value;
            }
        }

        /**
         * Validates the manually entered break end time.
         */
        function validateBreakEndTime() {
            const breakTimeInput = document.getElementById('breakEndTime');
            const newBreakTimeString = breakTimeInput.value;

            if (newBreakTimeString) {
                const [breakHour, breakMinute] = newBreakTimeString.split(':').map(Number);
                const [examHour, examMinute] = examEndTimeString.split(':').map(Number);

                const now = new Date();
                const breakDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), breakHour, breakMinute);
                const examEndDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), examHour, examMinute);

                // Ensure break time is strictly after exam end time (add 1 second buffer)
                if (!examEndTimeString || breakDate.getTime() > (examEndDate.getTime() + 1000)) {
                    breakEndTimeManual = newBreakTimeString;
                    saveToStorage();
                } else {
                    showMessage('Ung√ºltige Zeit', 'Die Pause Ende Zeit muss nach der Pr√ºfungsende Zeit liegen.');
                    breakTimeInput.value = breakEndTimeManual; // Revert to last valid time
                }
            } else {
                breakEndTimeManual = '';
                saveToStorage();
            }
        }

        /**
         * Clears the displayed exam and break end times.
         */
        function clearEndTimes() {
            document.getElementById('examEndTime').textContent = '--:--';
            document.getElementById('breakEndTime').value = '';
            examEndTimeString = '';
            breakEndTimeManual = '';
        }

        /**
         * Handles actions when the timer reaches zero.
         */
        function timerEnded() {
            clearInterval(timerInterval);
            isRunning = false;
            isPaused = false;

            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('pauseBtn').style.display = 'none';

            document.getElementById('timerDisplay').classList.remove('warning');

            playEndSound();
            showMessage('Zeit abgelaufen!', 'Die Pr√ºfungszeit ist beendet. Gut gemacht!');
            clearEndTimes();
            saveToStorage();
        }

        /**
         * Plays a cheerful sound using the Web Audio API.
         */
        function playEndSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();

            const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5 (C major chord)

            frequencies.forEach((freq, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);

                oscillator.start(audioContext.currentTime + index * 0.15);
                oscillator.stop(audioContext.currentTime + index * 0.15 + 0.8);
            });
        }

        /**
         * Adds a new question information entry or updates an existing one.
         */
        function addQuestionInfo() {
            const questionNumber = document.getElementById('questionNumber').value.trim();
            const questionText = document.getElementById('questionText').value.trim();

            if (questionNumber && questionText) {
                questionInfos = questionInfos.filter(info => info.number !== questionNumber);
                questionInfos.push({
                    number: questionNumber,
                    text: questionText // Store raw markdown
                });

                questionInfos.sort((a, b) => {
                    const aNum = parseFloat(a.number.replace(/[^\d.]/g, '')) || 0;
                    const bNum = parseFloat(b.number.replace(/[^\d.]/g, '')) || 0;
                    return aNum - bNum;
                });

                updateInfoDisplay(); // Refresh the display and adjust font size
                saveToStorage();

                document.getElementById('questionNumber').value = '';
                document.getElementById('questionText').value = '';
            }
        }

        /**
         * Updates the display area for additional question information.
         * Applies Markdown rendering and dynamically adjusts font size.
         */
        function updateInfoDisplay() {
            const display = document.getElementById('infoDisplay');

            if (questionInfos.length === 0) {
                display.innerHTML = '<div style="font-size: 30px; color: #7f8c8d; text-align: center; padding: 40px;">Keine zus√§tzlichen Informationen vorhanden</div>';
                // Reset font size if no content
                display.querySelectorAll('.info-question, .info-text').forEach(el => el.style.fontSize = '');
                return;
            }

            // Render content with new "Aufg. X)" format
            display.innerHTML = questionInfos.map(info => `
                <div class="info-item">
                    <div class="info-question">Aufg. <b>${info.number}</b>)</div>
                    <div class="info-text">${marked.parse(info.text)}</div>
                </div>
            `).join('');

            // Adjust font size after content is rendered and height is set
            adjustInfoDisplayFontSize();
        }

        /**
         * Adjusts the height of the info-display to fit available screen space.
         */
        function adjustInfoDisplayHeight() {
            const dateInfo = document.querySelector('.date-info');
            const timerSection = document.querySelector('.timer-section');
            const additionalInfo = document.querySelector('.additional-info'); // Parent of info-display
            const infoInput = document.querySelector('.info-input');
            const fileControls = document.querySelector('.file-controls');
            const container = document.querySelector('.container');

            // Calculate heights of fixed/known elements
            const dateInfoHeight = dateInfo ? dateInfo.offsetHeight : 0;
            const timerSectionHeight = timerSection ? timerSection.offsetHeight : 0;
            const infoInputHeight = infoInput ? infoInput.offsetHeight : 0;
            const fileControlsHeight = fileControls ? fileControls.offsetHeight : 0;

            // Get the computed style of the body and container to account for padding
            const bodyStyle = getComputedStyle(document.body);
            const containerStyle = getComputedStyle(container);

            const bodyPaddingTop = parseFloat(bodyStyle.paddingTop);
            const bodyPaddingBottom = parseFloat(bodyStyle.paddingBottom);
            const containerPaddingTop = parseFloat(containerStyle.paddingTop);
            const containerPaddingBottom = parseFloat(containerStyle.paddingBottom);

            // Gaps between grid items are 20px
            const gridGaps = 20 * 2; // Gap between date-info and timer-section, and timer-section and additional-info

            const totalFixedHeight = dateInfoHeight + timerSectionHeight + infoInputHeight + fileControlsHeight +
                bodyPaddingTop + bodyPaddingBottom +
                containerPaddingTop + containerPaddingBottom +
                gridGaps;

            let availableHeight = window.innerHeight - totalFixedHeight;

            // Ensure a minimum height for usability (e.g., 100px)
            if (availableHeight < 100) {
                availableHeight = 100;
            }

            // Apply height to the info-display (the scrollable content area)
            document.getElementById('infoDisplay').style.height = `${availableHeight}px`;
        }

        /**
         * Dynamically adjusts the font size of content within info-display to fit.
         */
        function adjustInfoDisplayFontSize() {
            const infoDisplay = document.getElementById('infoDisplay');
            const infoItems = infoDisplay.querySelectorAll('.info-item');
            if (infoItems.length === 0) return;

            // Create a temporary div to measure content without affecting the visible layout
            const tempDiv = document.createElement('div');
            tempDiv.style.visibility = 'hidden';
            tempDiv.style.position = 'absolute';
            tempDiv.style.left = '-9999px';
            tempDiv.style.top = '-9999px';
            tempDiv.style.width = infoDisplay.clientWidth + 'px'; // Match width for accurate text wrapping
            tempDiv.style.height = 'auto'; // Auto height for content measurement
            tempDiv.style.overflow = 'hidden';
            document.body.appendChild(tempDiv);

            let minFontSize = 1; // Minimum readable font size
            let maxFontSize = 40; // Maximum desired font size for info-text
            let bestFitSize = minFontSize;

            let low = minFontSize;
            let high = maxFontSize;

            // Binary search to find the largest font size that fits
            while (low <= high) {
                let mid = Math.floor((low + high) / 2) | 0;

                tempDiv.innerHTML = ''; // Clear content for new measurement
                infoItems.forEach(item => {
                    const clonedItem = item.cloneNode(true);
                    // Apply trial font sizes
                    clonedItem.querySelector('.info-question').style.fontSize = `${mid}px`;
                    clonedItem.querySelector('.info-text').style.fontSize = `${mid}px`;
                    tempDiv.appendChild(clonedItem);
                });

                // Check if the content fits within the infoDisplay's clientHeight
                // clientHeight is the inner height of the element, excluding padding and border
                if (tempDiv.scrollHeight <= infoDisplay.clientHeight) {
                    bestFitSize = mid; // This size fits, try a larger one
                    low = mid + 1;
                } else {
                    high = mid - 1; // This size overflows, try a smaller one
                }
            }

            // Apply the best fit font size to the actual elements
            infoItems.forEach(item => {
                item.querySelector('.info-question').style.fontSize = `${bestFitSize}px`;
                item.querySelector('.info-text').style.fontSize = `${bestFitSize}px`;
            });

            document.body.removeChild(tempDiv); // Clean up the temporary div
        }


        /**
         * Saves the current application state to a global variable (for demo purposes).
         */
        function saveToStorage() {
            const data = {
                questionInfos: questionInfos,
                timerMinutes: timerMinutes,
                remainingSeconds: remainingSeconds,
                isRunning: isRunning,
                isPaused: isPaused,
                breakEndTimeManual: breakEndTimeManual,
                examEndTimeString: examEndTimeString
            };
            window.savedData = data;
        }

        /**
         * Loads the application state from a global variable (for demo purposes).
         * Prioritizes URL hash for initial timer setting if present.
         */
        function loadFromStorage() {
            const data = window.savedData;
            if (data) {
                questionInfos = data.questionInfos || [];

                // Only load timerMinutes from storage if URL param was NOT set,
                // OR if URL param was set but the stored state implies an active timer
                // (meaning the user started/paused it, overriding initial URL param).
                const urlTimerSet = window.location.hash.indexOf('#t=') !== -1;
                if (!urlTimerSet || (data.isRunning || data.isPaused)) {
                    timerMinutes = data.timerMinutes !== undefined ? data.timerMinutes : 90;
                    remainingSeconds = data.remainingSeconds !== undefined ? data.remainingSeconds : timerMinutes * 60;
                    isRunning = data.isRunning || false;
                    isPaused = data.isPaused || false;
                }
                // If URL timer was set and no active stored timer, use URL timer value.
                // This is handled by parseUrlForTimer() which runs before loadFromStorage().

                breakEndTimeManual = data.breakEndTimeManual || '';
                examEndTimeString = data.examEndTimeString || '';

                document.getElementById('breakEndTime').value = breakEndTimeManual;
                document.getElementById('examEndTime').textContent = examEndTimeString || '--:--';

                if (isRunning) {
                    startTimer();
                } else if (isPaused) {
                    updateTimerDisplay();
                    document.getElementById('startBtn').style.display = 'inline-block';
                    document.getElementById('pauseBtn').style.display = 'none';
                } else {
                    updateTimerDisplay();
                }
                // updateInfoDisplay() is called by init() later, which then calls adjustInfoDisplayFontSize()
            }
        }

        /**
         * Exports the current application data as a JSON file.
         */
        function exportData() {
            const data = {
                questionInfos: questionInfos,
                timerMinutes: timerMinutes,
                remainingSeconds: remainingSeconds,
                isRunning: isRunning,
                isPaused: isPaused,
                breakEndTimeManual: breakEndTimeManual,
                examEndTimeString: examEndTimeString,
                exportDate: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `exam-dashboard-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        /**
         * Imports data from a selected JSON file, updating the dashboard state.
         */
        function importData(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.questionInfos) {
                            questionInfos = data.questionInfos;
                        }

                        if (data.timerMinutes !== undefined) {
                            timerMinutes = data.timerMinutes;
                            remainingSeconds = data.remainingSeconds !== undefined ? data.remainingSeconds : data.timerMinutes * 60;
                            isRunning = data.isRunning || false;
                            isPaused = data.isPaused || false;
                            breakEndTimeManual = data.breakEndTimeManual || '';
                            examEndTimeString = data.examEndTimeString || '';

                            document.getElementById('breakEndTime').value = breakEndTimeManual;
                            document.getElementById('examEndTime').textContent = examEndTimeString || '--:--';

                            clearInterval(timerInterval); // Stop current timer

                            if (isRunning) {
                                startTimer();
                            } else if (isPaused) {
                                updateTimerDisplay();
                                document.getElementById('startBtn').style.display = 'inline-block';
                                document.getElementById('pauseBtn').style.display = 'none';
                            } else {
                                updateTimerDisplay();
                                document.getElementById('startBtn').style.display = 'inline-block';
                                document.getElementById('pauseBtn').style.display = 'none';
                            }
                        }
                        saveToStorage();
                        updateInfoDisplay(); // Refresh info display (calls font size adjustment)
                        showMessage('Import Erfolgreich', 'Die Daten wurden erfolgreich importiert.');
                    } catch (error) {
                        showMessage('Import Fehler', 'Fehler beim Importieren der Datei: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
        }

        document.getElementById('questionText').addEventListener('keypress', function (e) {
            if (e.key === 'Enter' && !e.shiftKey) { // Allow Shift+Enter for new lines in textarea
                e.preventDefault(); // Prevent default new line behavior for Enter
                addQuestionInfo();
            }
        });

        window.addEventListener('load', init);

        function showMessage(title, message) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;
            document.getElementById('customModal').style.display = 'flex';
        }

        function hideMessage() {
            document.getElementById('customModal').style.display = 'none';
        }
    </script>
</body>

</html>
